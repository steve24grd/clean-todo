

## Step-by-step development sequence we followed

Below is the actual order of steps we took, with codebase references gathered via retrieval-only tools.

1) Installed dependencies
- Added ORM and driver:
  - @prisma/client (runtime)
  - prisma (CLI/dev)
  - sqlite3 (DB driver)
- Evidence:
  - package.json shows dependencies and scripts
    - prisma and @prisma/client added, sqlite3 present
    - scripts for prisma and tests added
  - References:
    - package.json (scripts, deps)

2) Initialized Prisma for SQLite
- Ran prisma init (created .env and prisma/schema.prisma)
- Evidence:
  - prisma/schema.prisma exists with generator and datasource blocks
- References:
  - prisma/schema.prisma

3) Defined Prisma schema for domain entities
- Modeled User and Todo based on existing domain (string IDs, unique email, nullable ownerId, timestamps)
- Evidence:
  - prisma/schema.prisma includes User and Todo models
- References:
  - prisma/schema.prisma

4) Created and applied initial migration
- Migrated schema to SQLite (dev.db) and generated migration SQL
- Evidence:
  - prisma/migrations/20251012065314_init/migration.sql present
  - migration_lock.toml indicates sqlite provider
- References:
  - prisma/migrations/20251012065314_init/migration.sql
  - prisma/migrations/migration_lock.toml

5) Implemented Prisma client wrapper (singleton)
- Outbound adapter helper to provide a single PrismaClient and handle shutdown
- Evidence:
  - src/adapters/outbound/persistence/prismaClient.ts exports getPrisma()
- References:
  - src/adapters/outbound/persistence/prismaClient.ts

6) Implemented Prisma-backed repository adapters
- PrismaUserRepository implements UserRepository
- PrismaTodoRepository implements TodoRepository
- Mapping DB rows to domain entities, using upsert for save
- Evidence:
  - src/adapters/outbound/persistence/PrismaUserRepository.ts
  - src/adapters/outbound/persistence/PrismaTodoRepository.ts
- References:
  - PrismaUserRepository
  - PrismaTodoRepository

7) Wired a Prisma-backed container and mounted v2 routes
- New container.prisma wires existing use cases to Prisma repositories
- main.ts mounts additional endpoints under /v2/users and /v2/todos
- Evidence:
  - src/container.prisma.ts creates Prisma repositories and use cases
  - src/main.ts imports buildPrismaContainer and mounts /v2 routes
- References:
  - src/container.prisma.ts
  - src/main.ts

8) Added scripts and tests, then validated
- package.json scripts for prisma and bun test
- tests/prisma.usecases.test.ts runs integration-style tests via use cases and Prisma repos; clears tables first
- Evidence:
  - package.json scripts
  - tests/prisma.usecases.test.ts with CreateUser/GetUser and Create/List/Complete Todo flow
- References:
  - package.json (scripts)
  - tests/prisma.usecases.test.ts

---

## Answers to your specific questions

1) Order of steps we took
- Install dependencies (Prisma, SQLite)
  - package.json shows @prisma/client, prisma, sqlite3
- Initialize Prisma (prisma init)
  - prisma/schema.prisma created
- Define schema (User, Todo)
  - prisma/schema.prisma models present
- Run migration (create tables, unique constraints)
  - prisma/migrations/20251012065314_init/migration.sql present
- Implement Prisma client singleton
  - src/adapters/outbound/persistence/prismaClient.ts
- Implement repository adapters
  - PrismaUserRepository, PrismaTodoRepository
- Add container for Prisma and mount v2 routes
  - src/container.prisma.ts; main.ts mounts /v2/users and /v2/todos
- Add scripts and tests; run tests
  - package.json scripts; tests/prisma.usecases.test.ts

2) Did we define schema and run migrations BEFORE implementing adapters?
- Yes. The schema and initial migration exist (prisma/schema.prisma and migrations) prior to adapter usage, and Prisma repositories depend on types generated by @prisma/client (which is generated from the schema/migration). Repos use getPrisma().user and getPrisma().todo—these require the client.

3) Reasoning behind this sequence
- Why schema/migration before adapters?
  - Repositories need concrete tables/fields to target and a generated Prisma Client API surface. The client generation is based on the schema; without it, TypeScript types (e.g., prisma.user.findUnique) aren’t available.
  - Evidence: prismaClient.ts imports PrismaClient from @prisma/client; repositories call prisma.user and prisma.todo methods, which come from generated client.
- How did domain entities and repository interfaces influence schema?
  - Domain entities define fields and invariants:
    - User: id (string), name, email (unique)
    - Todo: id (string), title, description?, ownerId?, isCompleted, createdAt, completedAt?
  - Repository ports define access patterns:
    - UserRepository requires findByEmail() → drove email unique index
    - TodoRepository requires listByOwner(null | id) and listAll() → ownerId nullable and relation with onDelete: SetNull
  - Evidence: schema fields match entity properties; unique index created for email; relation defined with nullable ownerId and SetNull
- Did Prisma Client generation need to happen before writing adapters?
  - Practically yes for compilation and DX. The adapter code imports PrismaClient types and uses prisma.user/prisma.todo; these APIs/types come from the generated client (based on the schema). While you could stub during development, to compile and run, generation must occur post-schema.

4) Recommended workflow when adding a new persistence adapter (with domain and ports already defined)
- Suggested sequence:
  1. Confirm domain entities and outbound ports (User, Todo; UserRepository, TodoRepository)
  2. Install ORM + driver
  3. Initialize ORM config
  4. Design ORM schema from domain and repository needs
     - Preserve domain IDs/constraints (string IDs here)
     - Add indices/uniques per repository lookup patterns (e.g., email unique)
     - Set relations consistent with domain (ownerId optional, onDelete behavior)
  5. Run migration (create/update DB schema)
  6. Generate client (so types exist)
  7. Implement repository adapters against ports using the client
  8. Wire a container that swaps in the new adapter; add new routes/endpoints if you want side-by-side operation
  9. Add tests (integration tests for adapters/use cases)
  10. Optionally add seed scripts and dev tooling (studio, scripts)

This mirrors the dependency direction in Clean Architecture:
- Domain and ports were stable
- We added a new outbound adapter that depends on ports and ORM
- We kept HTTP routes/use cases unchanged, simply wiring a second container and adding v2 mounts

---

## Key references (from the repo)
- Schema and migrations:
  - prisma/schema.prisma
  - prisma/migrations/20251012065314_init/migration.sql
- Prisma client and repositories:
  - src/adapters/outbound/persistence/prismaClient.ts
  - src/adapters/outbound/persistence/PrismaUserRepository.ts
  - src/adapters/outbound/persistence/PrismaTodoRepository.ts
- Wiring and routes:
  - src/container.prisma.ts
  - src/main.ts (mounts /v2/users and /v2/todos)
- Scripts and tests:
  - package.json (scripts)
  - tests/prisma.usecases.test.ts

If you want, I can also document this sequence in the README under a “Persistence adapters” section.
